//
// Created by c1533 on 2022/10/9.
//
/**堆排序
 * 属于选择排序，思想同简单选择排序一样。难理解，高频考点
 *
 * 堆：若n个关键字序列L[1...n]满足下面某一性质，则称为堆(Heap)
 * 1. 若满足：L(i)>=L(2i) && L(i)>=L(2i+1)  (1<=i<=n/2)     ->大根堆
 * 2. 若满足：L(i)<=L(2i) && L(i)<=L(2i+1)  (1<=i<=n/2)     ->小根堆
 *
 * 二叉树的顺序存储中几个重要基本操作：
 * i的左孩子——2i
 * i的右孩子——2i+1
 * i的父结点——[i/2]
 * i所在的层次——[log_2(n+1)]或[log_2n]+1
 * 判断i是否有左孩子？——2i<=n?
 * 判断i是否有右孩子？——2i+1<=n?
 * 判断i是否是叶子/分支结点？——i>[n/2]?
 * 即：
 * 靠前的部分多为分支结点，靠后的为叶子结点，在完全二叉树中：
 * 大根堆->父结点大于孩子结点
 * 小根堆->父结点小于孩子结点
 * */
/**建立大根堆
 * 对初始序列，大根堆：根>=左、右
 * 思路：把所有非终端结点都检查一边，是否满足大根堆要求，如果不满足，则调整
 * 在顺序存储的完全二叉树中，下标i<=[n/2]的都是非终端结点
 * 调整方式：将当前结点与更大的一个孩子互换
 * 当一轮互换结束后，下坠的元素可能引起子树不符合大根堆，所以需要继续用以上步骤互换
 *
 * */
void swap(int &a, int &b) {
    int t = a;
    a = b;
    b = t;
}
//将以k为根的子树调整为大根堆
void HeadAdjust(int A[], int k, int len) {
    A[0] = A[k];        //A[0]暂存子树的根结点
    for (int i = 2 * k; i <= len; i *= 2) {     //沿key较大的字节的向下筛选
        if (i < len && A[i] < A[i + 1])     //对比该结点的左、右孩子谁更大    i<len，才能确定是否有右兄弟
            i++;        //取key较大的字节的向下筛选    如果右孩子更大，i向后移动
        if (A[0] >= A[i])
            break;      //筛选结束
        else {
            A[k] = A[i];        //将A[i]调整到双亲结点上
            k = i;      //修改k值，以便继续向下筛选
        }
    }
    A[k] = A[0];        //被筛选结点的值放入最终位置
}
//建立大根堆
void BuildMaxHeap(int A[], int len) {
    for (int i = len / 2; i > 0; i--)       //从后(n/2处)往前调整所有非终端结点
        HeadAdjust(A, i, len);
}
/**基于大根堆进行排序
 * 选择排序
 * 堆排序：每一趟将堆顶元素加入有序子序列并将待排序元素序列再次调整为大根堆
 *
 * 建立大根堆树后，顶部元素最大，且在待排序序列第一个位置；
 * 将第一个位置的元素与最后一个位置的元素交换；
 * 交换位置后，对剩下的len-1个元素调整为大根堆，小元素下坠；
 * 最后得到从小到大的序列
 * */
//堆排序
void HeapSort(int A[],int len){
    BuildMaxHeap(A, len);       //原始序列建立成大根堆
    for(int i=len;i>1;i--){         //n-1躺的交换和建堆过程
        swap(A[i],A[1]);        //堆顶元素和堆底元素交换
        HeadAdjust(A, 1, i-1);      //剩余对象建立大根堆
    }
}
/**算法效率分析
 * 一个结点每下坠一层，最多只需对比关键字两次
 * 空间：O(1)
 * 时间：O(n)+O(nlog_2n)=O(nlog_2n)
 * 稳定性：不稳定
 * 基于大根堆得到递增序列，小根堆得到递减序列
 * */

/**插入
 * 对于小根堆，新元素放到表尾，与父结点对比，若新元素比父结点小，则将二者互换，直到无法上升为止
 * 对大根堆？
 * */
 /**删除
  * 对小根堆：被删除的元素用堆底元素替代，然后让该元素不断下坠(小的在根节点)，直到无法下坠为止
  *对大根堆？
  * */