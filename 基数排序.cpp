//
// Created by c1533 on 2022/10/11.
//
/**基数排序
 * 对n个数字的序列(以三位数以下的数字为例)
 * 首先按照个位(0~9)大小分配，分配到10个不同的组中，按照初始序列分，然后将每一组按从大到小，从上到下的顺序收集
 * 形成新序列，此序列的个位数按照从大到小排列的序列
 * 第二次按照十位分配收集，第三次按照百位分配收集
 * 由于从小的位数开始，可以保证低位大的先入队，则出的时候大的在小的前面
 *
 * 得到递减序列的过程：
 * 初始化：设置r个空队列，分别对应r中取值
 * 按照各个关键字位权重递增的次序(个位数对关键字整体影响最小，其次十位，最后百位)，对d个关键字位分别做分配和收集
 * 分配：
 * 顺序：扫描各个元素，若当前处理的关键字位=x，则将元素插入Qx队尾
 * 收集：把Qr-1，……Qr-2，……Q0各个队列中的结点一次出队并连接(倒着收集就是递增序列)
 * */
//基数排序不是基于“比较”的排序算法
typedef struct LinkNode {   //基数排序通常基于链式存储实现
    int data;
    struct LinkNode *next;
} LinkNode, *LinkList;
typedef struct {     //链式队列
    LinkNode *front, *rear;
} LinkQueue;
/**算法效率分析
 * 空间复杂度：O(r)   需要r个辅助队列
 * 总时间复杂度：O(d(n+r))     一趟分配O(n)，一趟收集O(r)，总共d趟分配收集
 * 稳定性：稳定
 * */
//应用：学校有10000个学生，将学生信息按照年龄递减排序
// 生日可以拆分位三组关键字：年、月、日，进行三趟分配
// 第一趟先收集按日递增；第二趟收集按月递增；第三趟收集和分配按年递增
/**基数排序擅长解决的问题：
 * 1. 数据元素的关键字可以方便的拆分为d组，且d较小
 * 2. 每组关键字的取值范围不大，即r较小
 * 3. 数据元素个数n较大
 * */
